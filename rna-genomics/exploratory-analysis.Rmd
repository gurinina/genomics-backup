# Exploratory Analysis


# RNAseq exploration

This should be the same counts file you generated, but now we're going to do a bit more with them in R. There are six yeast RNAseq samples.


## Setup


```{r}

# default to not showing code, you can change it for chunks as you like
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)


```


```{r LoadPackages, results='hide', include=FALSE}

# Install function for packages (I shamelessly stole this from stackoverflow)
packages<-function(x){
  x<-as.character(match.call()[[2]])
  if (!require(x,character.only=TRUE)){
    install.packages(pkgs=x,repos="http://cran.r-project.org")
    require(x,character.only=TRUE)
  }
}

bioconductors <- function(x){
    x<- as.character(match.call()[[2]])
    if (!require(x, character.only = TRUE)){
      if (!require("BiocManager", quietly = TRUE))
      install.packages("BiocManager")
      BiocManager::install(x)
      require(x, character.only = TRUE)
    }
}




packages(ggplot2)
packages(pheatmap)
packages(plyr)
packages(dplyr)
packages(tidyr)
packages(data.table)
bioconductors(edgeR)

library(ggplot2)
library(pheatmap)
library(plyr)
library(dplyr)
library(tidyr)
library(data.table)
library(edgeR)
library(readr)

```




First, we we will import the raw gene counts we generated from featureCounts and the sample to condition correspondence (experimental design).

As a comparison, we will run the alignments in R using the Rsubread package. Make sure you have a copy of Saccharomyces_cerevisiae.R64-1-1.96.gtf.gz and Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa.gz in your home directory 
```{r ReadingData}



fastq = list.files("FASTQ")
g = grep("fastq",fastq)
fastq = fastq[g]
fastq.files = paste("FASTQ",fastq,sep = "/")
fastq.files = file.path("FASTQ",fastq)

bam = list.files("BAM")
g = grep("bam$",bam)
bam = bam[g]
bam.files = file.path("BAM",bam)
gtf.file = "FASTQ/r64/Saccharomyces_cerevisiae.R64-1-1.96.gtf.gz"


```

Now we'll run the alignment:
```{r eval=FALSE}


library(Rsubread)
Rsubread::buildindex(basename="r64/r64.index", memory = 1000,
reference="FASTQ/r64/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa.gz")

align(index = "r64/r64.index", readfile1 = fastq.files,
output_file = bam.files,useAnnotation=TRUE,annot.ext = "FASTQ/Saccharomyces_cerevisiae.R64-1-1.96.gtf.gz",isGTF = TRUE,nthreads=64,sortReadsByCoordinates=TRUE, keepReadOrder=FALSE)

```


There are two ways of getting the count files. One is by using `featureCounts` from the Rsubread package, and the other uses `summarizeOverlaps` from the GenomicAlignments package. The former makes use of the gtf file and the bam files, while th latter uses exons extracted from the TxDb object made from the transcripts stored in the gtf file. 
```{r counts}
library(Rsubread)
bam = list.files("BAM")
g = grep("bam$",bam)
bam = bam[g]
bam.files = file.path("BAM",bam)
gtf.file = "FASTQ/r64/Saccharomyces_cerevisiae.R64-1-1.96.gtf.gz"

fc <- featureCounts(bam.files, annot.ext=gtf.file,
isGTFAnnotationFile=TRUE,
isPaired=FALSE)

library(GenomicFeatures)
txdb <- makeTxDbFromGFF(gtf.file, format="gtf")
exons.by.gene <- exonsBy(txdb, by="gene")

library(Rsamtools)

bam.list <- BamFileList(bam.files)

library(GenomicAlignments)

se <- summarizeOverlaps(exons.by.gene, bam.list,
mode="Union",
singleEnd=TRUE,
ignore.strand=FALSE,
fragments=FALSE)

```

Now let's plot the two against each other to see how they compare.

Compare summarizedOverlaps to featureCounts: 
```{r}
m=match(rownames(assay(se) ),rownames(fc$counts))

plot(assay(se[,1]),fc$counts[m,1],ylab = "featureCounts",xlab = "summarizeOverlaps")

counts = fc$counts 
g = grep("^Y",rownames(counts))
counts = counts[g,]

## From the script subreadMapping.sh
# cnts = read_tsv("counts.txt",skip = 1)

#table(all.equal(cbind(fc$abundance,fc$counts),cnts))
```
 
We can see that, while linear and not to far from a slope of one, the counts are higher for the featureCounts  sample. Can anyone guess why this is happening?

count vs transcript: 
```{r transcripts}

library(org.Sc.sgd.db)
eid = keys(org.Sc.sgd.db)
gene=AnnotationDbi::mapIds(org.Sc.sgd.db, keys = eid, column = "GENENAME", keytype = "ORF")

m=match(rownames(counts),names(gene))

table(is.na(m))

wna = which(is.na(gene))

gene[wna]=names(gene)[wna]

length(wna)
genecnts = counts
rownames(genecnts)=gene[m]
```


Let's first rename our colnames of counts from bamfile names back to our sample names:
```{r rename}


library(readr)
library(dplyr)
samples <- read_csv("https://osf.io/cxp2w/download")
samples = samples[,-2]
names(samples)[2] = "genome"
samples$genome = factor(samples$genome)
samples$genome = relevel(samples$genome,ref = "wt")
samples = samples %>% arrange(samples)
samples$sample
colnames(counts)
```

Looks good:
```{r}
colnames(counts) = samples$sample
```

## Summary statistics
```{r modeling with edgeR, results=FALSE}

# Even though we're just doing exploration, we're going to put the data into edgeR here. That's because it will make a compact data structure that holds all the counts, as well as the metadata. It makes it way easier to do a lot of other exploration once it's in that structure.
yDGE <- DGEList(counts, group = samples$genome)

# yDGE

head(yDGE$counts) # original count matrix
yDGE$samples # contains a summary of your samples
sum( yDGE$all.zeros ) # How many genes have 0 counts across all samples

yDGE <- calcNormFactors(yDGE)
design <- model.matrix(~genome, samples)
yDGE <- estimateDisp(yDGE, design)

```

These are our library sizes (both raw, and in millions of reads)
```{r}

colSums( yDGE$counts ) # Library Sizes
colSums( yDGE$counts) / 1e06 # Library Sizes in millions of reads

```

Here is a summary of our samples
```{r}
yDGE$samples # contains a summary of your samples

```

Check the yDGE object
```{r}

dim(yDGE$counts)
head(yDGE$counts) # original count matrix
sum( yDGE$all.zeros ) # How many genes have 0 counts across all samples

```


We need to filter the counts that do not have a worthwhile number of reads in any sample from the downstream analyses. There are several reasons for this. From a biological point of view, these genes represent genes that not expressed at a biologically meaningful level in any condition and are therefore best ignored. From a statistical view, removing low count genes allows the mean-variance relationship in the data to be estimated with greater reliability. 

The filterByExpr function in the edgeR package provides an automatic way to filter genes, while keeping as many genes as possible with worthwhile count

So what are you doing here? First you are counting up the number of times in each row a value is greater than 1. So that part is going to vary from 0 to 6. Then you are counting up the number of times those rowSums is greater than or equal to the size 
of your group, which is 3. That's just a rule of thumb for filtering low reads.
```{r}
keepers <- rowSums(cpm(yDGE)>1)>=3

dim(yDGE)

yDGE <- yDGE[keepers,]

dim(yDGE)

yDGE <- calcNormFactors(yDGE)
```
## Clustering plots

### Heatmap 

A useful first step in an RNA-seq analysis is often to assess overall similarity between samples: Which samples are similar to each other, which are different? Does this fit to the expectation from the experiment’s design? To draw a heatmap of individual RNA-seq samples, we suggest using moderated log-counts-per-million. This can be
calculated by cpm with positive values for prior.count:

```{r Heatmap}
logcpm <- cpm(yDGE, prior.count=10, log=TRUE)
library(pheatmap)
pheatmap(logcpm, show_colnames=TRUE, show_rownames=FALSE)
```

### PCA for overall expression

We can also look at how well the samples separate just by their expression levels
```{r}

library(ggplot2)

yPCA <- prcomp(x = t(logcpm), center = TRUE, scale = FALSE)

yPCA <- as.data.frame(yPCA$x)

ggplot(yPCA, aes(PC1, PC2, col=samples$genome)) + geom_point()


```

## edgeR exploration and analysis

### Dispersion

This is a bit of exploration of what dispersion parameters we should use. edgeR defaults to a prior.n of 10:
```{r}

yDGE <- estimateTagwiseDisp( yDGE , prior.n = 10 )
summary( yDGE$tagwise.dispersion )

```


What happens if we increase the shrinkage/sqeezing toward the common?
```{r}

yDGE <- estimateTagwiseDisp( yDGE , prior.n = 25 )
summary( yDGE$tagwise.dispersion ) # didn't change anything



```

Looks like nothing! Let's keep the original.
```{r}
# The recommended setting for this data set is the default of 10. Let’s stick with that.
yDGE <- estimateTagwiseDisp( yDGE , prior.n = 10 )
```

### Mean and variance modeling

We can also look at how the mean and variance spread for this particular data set. This would tell you whether the default distribution is useful for your model:
```{r}
meanVarPlot <- plotMeanVar( yDGE, show.raw.vars=TRUE,
                            show.tagwise.vars=TRUE,
                            show.binned.common.disp.vars=FALSE,
                            show.ave.raw.vars=FALSE,
                            dispersion.method = "qcml", NBline = TRUE,
                            nbins = 100,
                            pch = 16 ,
                            xlab ="Mean Expression (Log10 Scale)",
                            ylab = "Variance (Log10 Scale)",
                            main = "Mean-Variance Plot" )
```

## Analysis

Finally, we can get a list of differentially expressed genes!

Model mean-variance trend and fit linear model to data ----
Use VOOM function from Limma package to model the mean-variance relationship
```{r}

# fit a linear model to your data
vDGE <- voom(yDGE,design, plot = TRUE)
fits <- lmFit(vDGE, design)

```

extract the linear model fit -----
```{r}
# get bayesian stats for your linear model fit
ebFit <- eBayes(fits)

```


TopTable to view DEGs -----
```{r}
TopHits <- topTable(ebFit, adjust ="BH", coef=2, number = nrow(counts))

```


### DE plots

With the models run, we can also plot some things about the analyzed data, to decide if our analysis is good or not

The function plotMDS draws a multi-dimensional scaling plot of the RNA samples in which distances
correspond to leading log-fold-changes between each pair of RNA samples:
```{r}
plotMDS(yDGE, col = as.numeric(yDGE$samples$group))
```

**Exercise**
Load the DESeq2 library. Create a DESeq2 object named dds from the gene read count and sample information from the yDGE object.
```{r}

```

**Exercise**
Create a PCA plot from the DESeq2 object, using the vsd transformation and 500 of the most variable genes (default for plotPCA).
```{r}



```

The vst(dds, blind=FALSE) part performs a variance stabilizing transformation of the normalized counts, to prevent a handful genes with the highest expression levels and most variance from dominating the PCA plot.

**Exercise**
Create another PCA plot, this time using the 100 most variable genes (ntop=100), instead of the default of 500.
```{r}

```

**Exercise**
Perform the DESeq analysis on the dds dataset and get the results
```{r}


```


Get information on what the columns of the results contain:
```{r}

```



Filter the results for FDR < 0.05 and absolute value of Fold-Change > 2 (i.e., at least double or half the level of expression)

Make a dataframe with ORF and GENE as columns and arrange the data in order of padj and descending order by absolute value of log2FoldChange. Filter the results for those records that have padj < 0.05 and absolute value of res$log2FoldChange > 2.
```{r}

```

**Shrinkage of log fold change of genes with very low expression.**
Genes with very low expression usually have very noisy estimates of log2 fold changes. It is desirable to shrink the fold change of genes with low read counts, but not shrink the fold change of highly expressed genes too much. DEseq2 has implemented several different algorithms for shrinkage. The DESeq2 developers recommend to use apeglm method for shrinkage. Shrinkage is especially important if you plan to use LFC to rank genes for enrichment analysis (e.g., GSEA, to be covered next week).

Perform the shrinkage with "apeglm", then compare the MA plot
with or without shrinkage. 
```{r}


```

How do the edgeR results compare the the DESeq results?


IGV

The Integrative Genomics Viewer (IGV) is a high-performance, easy-to-use, interactive tool for the visual exploration of genomic data. It supports flexible integration of all the common types of genomic data and metadata, investigator-generated or publicly available, loaded from local or cloud sources.

Development of IGV has been supported by funding from the National Cancer Institute (NCI) of the National Institutes of Health, the Informatics Technology for Cancer Reserarch (ITCR) of the NCI, and the Starr Cancer Consortium.

[James T. Robinson, Helga Thorvaldsdóttir, Wendy Winckler, Mitchell Guttman, Eric S. Lander, Gad Getz, Jill P. Mesirov. Integrative Genomics Viewer. Nature Biotechnology 29, 24–26 (2011).](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3346182/)

https://software.broadinstitute.org/software/igv/download


For this exercise we’ll be making use of IGV that you downloaded. The Saccharomyces cerevisiae genome that we used for the mapping is available here. It can be found under Genome -> S. cerevisiae (sacCer3)

The BAM files can be added tracks. Choose “Tracks -> local file”. Select all the .bam files and the accompanying .bai files.

You should get something like this:

[!Figure.1](figures/fullgenomeIGV.png)


If we want to see are reads we have to zoom in. Unfortunately, the web app doesn't make it easy to search for genes so we have to do it the hard way.

Question: pick five of your top hits in the DESeq2 analysis and see if they check out.



Question:

Pick a sample and visualize the forward and reverse alignments separately in IGV.

Solution
Select and sort forward reads in one go.
samtools view -Sb -F 20 Arabidopsis_sample1.bam | samtools sort -o Arabidopsis_FW_sorted.bam
Index the forward reads.
samtools index Arabidopsis_FW_sorted.bam
Select and sort the reverse reads.
samtools view -Sb -f 16 Arabidopsis_sample1.bam | samtools sort -o Arabidopsis_RV_sorted.bam
Index the reverse reads.
samtools index Arabidopsis_RV_sorted.bam


Upload the files in IGV and you should get something like this.



[!Figure.2](figures/gene10370.png)






